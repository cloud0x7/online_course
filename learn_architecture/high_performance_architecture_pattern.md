
#### 高性能数据库集群：读写分离
* 读写分离的基本实现
  - 数据库服务器搭建主从集群，一主一从、一主多从都可以
  - 数据库主机负责读写操作，从机只负责读操作
  - 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据
  - 业务服务器将写操作发给数据库主机，将读操作发给数据库从机
* 会引入复杂度的细节点
  - 复制延迟：延迟导致读取不到问题
    - 解决方法：
      - 1）写操作后的读操作发给主服务器；（侵入式较大）
      - 2）读从机失败后再读一次（大量二次读导致服务器压力大）
      - 3）关键业务读写操作都在主服务器
  - 分配机制的实现方式
    - 程序代码封装：简单；多语言无法通用；故障下切换要改配置及重启
    - 中间件封装：支持多语言；实现复杂，容易出bug，需要长时间来稳定；性能要求高；
      - 开源方案：MySQL Router；Atlas
* 其它概念
  - “从机”提供读功能；备机只提供备份功能
  

#### 高性能数据库集群：分库分表
* 大数据量的存储压力
  - 读写性能降低
  - 数据文件变大，备份和恢复耗时很长
  - 数据文件越大，丢失数据的风险越高
* 分库分表
  - 业务分库：按业务模块将数据分散到不同的数据库服务器
    - 新问题：
      - join操作无法使用
      - 事务问题
      - 成本增加
  - 分表：垂直分表 和 水平分表
    - 垂直分表：拆分不常用但占用大量空间的列；缺点操作表次数增加
    - 水平分表：适合记录特别多的表，看表的访问性能
      - 新问题引入的复杂度
        - 路由：范围路由、Hash路由、配置路由
        - join操作
        - count操作：count相加；记录数表
        - order by操作
* 分库分表实现方法
  - 程序代码封装
  - 中间件封装
* 问题：什么时候引入分库分表操作
  - 答：依次尝试如下操作：1.硬件优化，如升级SSD硬盘；2.数据库调优，如索引和参数调整；3.引入缓存，减少数据库压力；4.代码优化；5.考虑分库分表
  
  
#### 高性能NoSQL
* 关系数据库存在如下缺点
  - 1.无法存储数据结构
  - 2.schema不易扩展，修改要锁表
  - 3.I/O高
  - 4.全文搜索功能弱
* 常见NOSQL方案
  - K-V存储：Redis代表，解决1
  - 文档数据库：MongoDB代表，解决2
  - 列式数据库：HBase代表，解决3
  - 全文搜索引擎：Elasticsearch代表，解决4
* NOSQL特征和场景
  - K-V存储：Redis不支持典型完整的ACID事务
  - 文档数据库：特点no-schema，使用json自描述
    - 新增字段简单；历史数据兼容性好；容易存储复杂数据；特别适合电商和游戏类业务场景；不支持事务；不支持join操作
  - 列式数据库
    - 高存储压缩比；用于离线大数据分析统计
  - 全文搜索引擎：
    - 倒排索引
    

#### 高性能缓存架构
* 应用场景
  - 需要经过复杂运算后得出的数据
  - 读多写少
* 缓存带来性能大幅提升：Memcache单台查询能达到TPS 50000以上
* 缓存带来的复杂性
  - 缓存穿透
    - 存储数据不存在：设置默认值
    - 缓存数据生成耗费大量时间或资源
  - 缓存雪崩：缓存失效后引起的系统性能急剧下降
    - 解决方案一：更新锁，只有一个线程更新缓存，分布式需要用到分布式锁
    - 解决方案二：后台更新，缓存设置为不过期，后台线程定时更新；也适合业务刚上线的缓存预热
  - 缓存热点：复制多份缓存副本，请求分散到多点，注意过期时间设置为范围内随机，而不是统一时间
* 实现方式：代码 或 独立中间层 实现


#### 单服务器高性能模式
* 高性能设计：提升单台性能；设计集群方案
* 单服务器高性能关键点：**并发模型**
  - 服务器如何管理连接
  - 服务器如何处理请求
* PPC（Process Per Connection）和TPC（Thread Per Connection）
  - PPC缺点：fork代价高；父子进程通信复杂；支持的并发连接数有限
    - prefork：提前创建进程
  - TPC：新建线程处理请求，轻量级消耗少，共享内存空间，通信方便
    - 新问题：线程间互斥和共享引入复杂度，易死锁；互相影响，线程异常可导致进程退出
    - prethread：预先创建线程
* Apache服务器MPM worker模式：先创建多个进程，每个进程内再创建多个线程，为 了稳定
    
    
#### 单服务器高性能模式:Reactor与Proactor
* Reactor
  - 创建进程池复用资源
  - 读操作非阻塞，轮询连接
  - 连接上有数据的进程才去处理
* Proactor
  - 异步I/O
  
  
#### 高性能负载均衡：分类及架构
* 高性能集群的复杂性：增加一个任务分配器，选择一个任务分配算法
* 负载均衡分类
  - DNS负载均衡：地理级别
    - 优点：简单成本低；就近访问，速度快
    - 缺点：更新不及时；扩展性差；分配策略简单
  - 硬件负载均衡（百万级）
    - 优点：功能强；性能强；稳定高；支持安全防护
    - 缺点：昂贵；扩展能力差；
  - 软件负载均衡：常见Nginx(7层，五万级)和LVS(4层，十万级)
    - 优点：简单便宜灵活
    - 缺点：性能一般；无防火墙等安全功能
* 负载均衡典型架构：按需组合
  
  
#### 高性能负载均衡：算法
* 算法分类
  - 任务平分类：数量、比例或权重上的平均
  - 负载均衡类：根据服务器负载（CPU负载、连接数、IO、网卡吞吐量等）分配
  - 性能最优类：服务器响应时间
  - Hash类：关键信息（源地址、session id、用户ID等）进行Hash运算
* 算法介绍
  - 轮询：简单
  - 加权轮询：
  - 负载最低优先：
    - 代价是增加复杂度：收集服务器负载信息
    - 效果虽好，但没有轮询使用的多
  - 性能最优类：
  - Hash类：满足业务需求